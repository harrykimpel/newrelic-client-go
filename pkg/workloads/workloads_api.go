// Code generated by tutone: DO NOT EDIT
package workloads

import (
	"github.com/newrelic/newrelic-client-go/pkg/entities"
)

// Creates a new workload.
func (a *Workloads) WorkloadCreate(
	accountID int,
	workload WorkloadCreateInput,
) (*WorkloadCollection, error) {

	resp := WorkloadCreateResponse{}
	vars := map[string]interface{}{
		"accountId": accountID,
		"workload":  workload,
	}

	if err := a.client.NerdGraphQuery(WorkloadCreateMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.WorkloadCollection, nil
}

type WorkloadCreateResponse struct {
	WorkloadCollection WorkloadCollection `json:"WorkloadCreate"`
}

const WorkloadCreateMutation = `mutation(
	$accountId: Int!,
	$workload: WorkloadCreateInput!,
) { workloadCreate(
	accountId: $accountId,
	workload: $workload,
) {
	account {
		id
		name
	}
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	entities {
		guid
	}
	entitySearchQueries {
		createdAt
		createdBy {
			email
			gravatar
			id
			name
		}
		id
		query
		updatedAt
	}
	entitySearchQuery
	guid
	id
	name
	permalink
	scopeAccounts {
		accountIds
	}
	status {
		description
		source
		statusDetails {
			__typename
			source
			value
			... on WorkloadRollupRuleStatusResult {
				__typename
			}
			... on WorkloadStaticStatusResult {
				__typename
				description
				summary
			}
		}
		summary
		value
	}
	statusConfig {
		automatic {
			enabled
			rules {
				id
			}
		}
		static {
			description
			enabled
			id
			status
			summary
		}
	}
	updatedAt
} }`

// Deletes an existing workload.
func (a *Workloads) WorkloadDelete(
	gUID entities.EntityGUID,
) (*WorkloadCollection, error) {

	resp := WorkloadDeleteResponse{}
	vars := map[string]interface{}{
		"guid": gUID,
	}

	if err := a.client.NerdGraphQuery(WorkloadDeleteMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.WorkloadCollection, nil
}

type WorkloadDeleteResponse struct {
	WorkloadCollection WorkloadCollection `json:"WorkloadDelete"`
}

const WorkloadDeleteMutation = `mutation(
	$guid: EntityGuid!,
) { workloadDelete(
	guid: $guid,
) {
	account {
		id
		name
	}
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	entities {
		guid
	}
	entitySearchQueries {
		createdAt
		createdBy {
			email
			gravatar
			id
			name
		}
		id
		query
		updatedAt
	}
	entitySearchQuery
	guid
	id
	name
	permalink
	scopeAccounts {
		accountIds
	}
	status {
		description
		source
		statusDetails {
			__typename
			source
			value
			... on WorkloadRollupRuleStatusResult {
				__typename
			}
			... on WorkloadStaticStatusResult {
				__typename
				description
				summary
			}
		}
		summary
		value
	}
	statusConfig {
		automatic {
			enabled
			rules {
				id
			}
		}
		static {
			description
			enabled
			id
			status
			summary
		}
	}
	updatedAt
} }`

// Duplicates an existing workload.
func (a *Workloads) WorkloadDuplicate(
	accountID int,
	sourceGUID entities.EntityGUID,
	workload WorkloadDuplicateInput,
) (*WorkloadCollection, error) {

	resp := WorkloadDuplicateResponse{}
	vars := map[string]interface{}{
		"accountId":  accountID,
		"sourceGuid": sourceGUID,
		"workload":   workload,
	}

	if err := a.client.NerdGraphQuery(WorkloadDuplicateMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.WorkloadCollection, nil
}

type WorkloadDuplicateResponse struct {
	WorkloadCollection WorkloadCollection `json:"WorkloadDuplicate"`
}

const WorkloadDuplicateMutation = `mutation(
	$accountId: Int!,
	$sourceGuid: EntityGuid!,
	$workload: WorkloadDuplicateInput,
) { workloadDuplicate(
	accountId: $accountId,
	sourceGuid: $sourceGuid,
	workload: $workload,
) {
	account {
		id
		name
	}
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	entities {
		guid
	}
	entitySearchQueries {
		createdAt
		createdBy {
			email
			gravatar
			id
			name
		}
		id
		query
		updatedAt
	}
	entitySearchQuery
	guid
	id
	name
	permalink
	scopeAccounts {
		accountIds
	}
	status {
		description
		source
		statusDetails {
			__typename
			source
			value
			... on WorkloadRollupRuleStatusResult {
				__typename
			}
			... on WorkloadStaticStatusResult {
				__typename
				description
				summary
			}
		}
		summary
		value
	}
	statusConfig {
		automatic {
			enabled
			rules {
				id
			}
		}
		static {
			description
			enabled
			id
			status
			summary
		}
	}
	updatedAt
} }`

// Updates an existing workload.
func (a *Workloads) WorkloadUpdate(
	gUID entities.EntityGUID,
	workload WorkloadUpdateInput,
) (*WorkloadCollection, error) {

	resp := WorkloadUpdateResponse{}
	vars := map[string]interface{}{
		"guid":     gUID,
		"workload": workload,
	}

	if err := a.client.NerdGraphQuery(WorkloadUpdateMutation, vars, &resp); err != nil {
		return nil, err
	}

	return &resp.WorkloadCollection, nil
}

type WorkloadUpdateResponse struct {
	WorkloadCollection WorkloadCollection `json:"WorkloadUpdate"`
}

const WorkloadUpdateMutation = `mutation(
	$guid: EntityGuid!,
	$workload: WorkloadUpdateInput!,
) { workloadUpdate(
	guid: $guid,
	workload: $workload,
) {
	account {
		id
		name
	}
	createdAt
	createdBy {
		email
		gravatar
		id
		name
	}
	entities {
		guid
	}
	entitySearchQueries {
		createdAt
		createdBy {
			email
			gravatar
			id
			name
		}
		id
		query
		updatedAt
	}
	entitySearchQuery
	guid
	id
	name
	permalink
	scopeAccounts {
		accountIds
	}
	status {
		description
		source
		statusDetails {
			__typename
			source
			value
			... on WorkloadRollupRuleStatusResult {
				__typename
			}
			... on WorkloadStaticStatusResult {
				__typename
				description
				summary
			}
		}
		summary
		value
	}
	statusConfig {
		automatic {
			enabled
			rules {
				id
			}
		}
		static {
			description
			enabled
			id
			status
			summary
		}
	}
	updatedAt
} }`
